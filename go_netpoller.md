[zz] The Go netpoller | 2013-09-12
# The Go netpoller

[原文在此](http://morsmachine.dk/netpoller)

# 介绍

---

又到了探究go runtime的时候,这次我们将看看Go将如何处理网络I/O的.

# 阻塞式

---

在Go中,所有的I/O操作都是阻塞式的,
Go的设计思想是放弃阻塞式的接口,利用goroutine和channel来处理并发,
而不是传统的回调.一个显而易见的例子便是"net/http"包中的http服务器.
无论何时,当它接收一个连接,它将创建一个新的goroutine去处理该连接上的所有的请求.
这种架构使得处理的请求变得十分简单明了.先做这个,再做那个.
不幸的是,由操作系统提供的阻塞式I/O和我们自己构建的阻塞式I/O接口不匹配.

在前一篇关于go runtime的文章中,我阐述了go调度器如何处理系统调用的.
为了处理一个阻塞式的系统调用,我们需要一个线程一直阻塞在操作系统中.
如果我们想在操作系统的阻塞式I/O的基础上构建我们自己的阻塞式IO,
那么每当一个客户端阻塞在系统调用中,我们就需要创建一个新的线程.
这样如果我们有10000客户端线程都阻塞在系统调用中等待IO操作完成,
那么造成的代价将非常昂贵.

Go利用操作系统提供的异步接口解决了这个问题,
但是执行的IO的goroutine将会被阻塞.

# 网络轮询器

---

将异步IO转变成阻塞式IO的部分叫做网络轮询器.
它在它自己的线程环境中运行,
接收那些希望进行网络IO的goroutines发送过来的的事件.
网络轮询器利用的OS提供的轮询网络套接字的接口.
在Linux系统里,便是`epoll`,在BSD和Darwin中是`kqueue`,
而在Windows里,则是`IoCompletionPort`.
这些接口的共同点便是提供给用户态程序一种有效轮询网络IO状态的方法.

在Go中无论何时,当你打开或者接收一个连接时,
返回的文件描述符都被设置成了非阻塞模式.
这意味着如果你尝试在一个还没有准备好的文件描述符上进行IO操作,
它将立即返回一个错误.无论何时,当一个goroutine尝试在一个连接上进行读写,
当收到这样的错误时,runtime中网络部分的代码将会被执行,从而通知网络轮询器,
告诉它当该连接再次准备好进行IO操作时,通知该goroutine.
然后该goroutine将被从当前的线程上换出,另一个goroutine将被换入执行.

当网络轮询器接收到从OS发送过来的通知(该文件描述符已经准备好进行IO操作),
它将查询它内部的数据结构,看是否有goroutines阻塞在那个文件描述符上,
如果有的话,通知他们.那些goroutines将再次尝试进行IO操作,最终成功返回.

这听上去和用古老的`select`和`poll`Unix系统调用进行IO操作很像,
是的它们的确很像.不过这里没必要查询函数指针以及包含一堆状态变量的结构体,
取而代之的是网络轮询器查询可以被换入执行的goroutine.
这样,你就没必要管理那些状态、重复检查上一次是否接受到足够的数据、
根据不同的状态选择执行不同的函数,而这些操作在传统的Unix网络IO中,
是你必须要自己去做的.
